# 우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 
# 이때, 주어진 수의 순서를 바꾸면 안 된다.
# 연산자 우선순위 무시하고 앞에서부터 계산
# 나눗셈은 정수 나눗셈 => 몫 (//) 사용
# 음수를 양수로 나눌 때는  양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다.
# N개의 수와 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하기

N = int(input())
nums = list(map(int, input().split()))
# 각 연산자의 개수 (+, -, *, /)
ops = list(map(int, input().split()))

# 최대값, 최소값 초기화
max_v = -10**18
min_v = 10**18

def dfs(i, sum_v):
    '''
    i : 다음에 사용할 숫자의 인덱스 (0번 숫자를 초기값으로 쓰므로 1부터 시작함)
    sum_v : 지금까지 계산된 결과값(누적값)

    <과정>
    - 현재까지 만든 값(sum_v)에, 다음 숫자 nums[i]를 하나의 연산자로 이어 붙임.
    - 남아있는 연산자(ops[k])가 있으면 그 연산을 선택해서 재귀 호출!
    - i가 N이 되면(= 숫자 N개를 모두 사용) 하나의 완성된 식이므로 최대값/ 최솟값을 갱신하고 리턴함.
    '''

    global max_v, min_v

    # 숫자를 모두 사용했다면 (연산자도 N-1개 사용 완료)
    if i == N:
        max_v = max(max_v, sum_v)
        min_v = min(min_v, sum_v)
        return
    
    # 이번 단계에서 붙일 숫자
    b = nums[i]

    # 4개의 연산자 후보를 차례로 시도함
    for k in range(4):
        if ops[k] == 0:
            continue
        
        # 이 연산자를 한 번 사용한다고 가정하고 개수 하나 줄임
        ops[k] -= 1

        if k == 0:  # 덧셈
            dfs(i+1, sum_v + b)
        elif k == 1:    # 뺄셈
            dfs(i+1, sum_v - b)
        elif k == 2:    # 곱셈
            dfs(i+1, sum_v * b)
        else:   # 나눗셈
            # 0으로 나누는 경우는 패스 
            if b != 0:
                # 문제 규칙: 음수 나눗셈은 "0을 향해 버림(트렁케이션)"
                # 파이썬에서 // 는 "내림"이라 규칙과 다를 수 있으므로 int(cur / b)를 사용
                dfs(i+1, int(sum_v / b))

        ops[k] += 1

dfs(1, nums[0])

print(max_v)
print(min_v)

        
