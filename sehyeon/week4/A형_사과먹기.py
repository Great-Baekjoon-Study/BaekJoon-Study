# 플레이어의 시작 위치는 좌측 상단으로 고정
# 뒤로 이동 불가능
# 키보드의 오른쪽 방향키를 누를 때 마다 오른쪽으로 90도씩 회전한다.

# [제약사항]
# 1. 지도의 한 변의 크기 N은 5이상 10 이하의 정수이다. (5 ≤ N ≤ 10)
# 2. 사과의 개수 M은 2이상 10 이하의 정수이다. (2 ≤ M ≤ 10)
# 3. 새로운 사과가 나타날 때 바로 직전 사과와 동일한 열/행에 나타나지 않는다. 
# 4. 지도의 가장자리 영역에는 사과가 나타나지 않는다. 

# 방향 번호 약속: 0 = 동(E), 1 = 남(S), 2 = 서(W), 3 = 북(N) (동부터 시계방향)
# 격자 좌표계: 행(r)은 아래로 갈 수록 +, 열(c)은 오른쪽으로 갈 수록 +

def FR(dr, dc, d):
    """
    A=(r1,c1) 에서 B=(r2,c2)로 갈 때의 차이 (dr, dc)를
    '앞(Forward)=F'과 '오른쪽(Right)=R' 축으로 변환한다.
    - 현재 바라보는 방향 d가 무엇이냐에 따라 F, R의 계산식이 달라짐.
    - 아이디어: '앞' 축은 현재 진행방향, '오른쪽' 축은 그 오른쪽에 해당.
      F>0 이면 목적지가 '앞쪽', R>0 이면 '오른쪽 편'에 있다고 해석.
    """
    if d == 0:  # 동(E) : 오른쪽이 '앞'
        return dc, dr  # F = 열증가, R = 행증가
    if d == 1:  # 남(S): 아래쪽이 '앞'
        return dr, -dc  # F = 행증가, R = 열 감소
    if d == 2:  # 서(W) : 왼쪽이 '앞'
        return -dc, -dr # F = 행 감소, R = 열 감소
    # d == 3    # 북(N) : 위쪽이 '앞'
    return -dr, dc  # F = 행 감소, R = 열 증가


def turns(d, A, B, pivot_ok = False):
    """
    현재 방향 d에서 A -> B로 가려면 '오른쪽 회전'이 최소 몇 번 필요한지(t)와
    그 후 도착해서 바라보는 방향 end_dir을 계산한다.

    규칙 요약(오른쪽 회전만 가능):
      - R > 0:
          F > 0(앞쪽)  -> t = 1   (앞으로 가다 1번 꺾는 L자)
          F = 0(옆)  -> t = 2   (출발 즉시 꺾기 금지 → 한 칸 나가고 2번 꺾는 경로)
          F < 0(뒤쪽)  -> t = 2   (뒤쪽이므로 2번 꺾어 돌아들어감)
      - R < 0(왼쪽 편에 있음): t = 3  (왼쪽으로는 못 꺾으니 오른쪽으로 3번)
      - R = 0(앞 or 뒤 정면 라인):
          F > 0  -> t = 0   (그대로 직진)
          F < 0  -> t = 3   (뒤로는 못 가니 3번 돌아 사각형 경로)
          
    pivot_ok=True 이면 '현재 칸에서 즉시 1회 회전'을 허용(사과를 먹으며 회전).
    => R>0, F=0(정확히 옆칸)인 경우 t가 2 -> 1 로 줄어듦.
    """
    r1, c1 = A
    r2, c2 = B
    F, R = FR(r2 - r1, c2 - c1, d)

    if R > 0:   # 오른쪽 편에 있음
        t = 1 if F > 0 else 2   # 앞쪽(F > 0)에 있으면 한 번만 꺾고 아니면 2번 꺾기
    elif R < 0: # 왼쪽 편
        t = 3
    else:   # R = 0 (정면 라인)
        t = 0 if F > 0 else 3   # 앞은 0, 뒤는 3

    end_dir = (d + t) % 4  # t번 우회전 후의 방향
    return t, end_dir

# ------- 메인 -------
T = int(input())

for test_case in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]

# 1) 사과 개수 M(= 격자에서 가장 큰 번호)와 각 사과의 좌표를 모은다.
M = 0
for r in range(N):
    for c in range(N):
        if arr[r][c] > 0:            # 0은 사과 없음, 1..M은 '먹는 순서' 번호
            M = max(M, arr[r][c])    # 가장 큰 번호를 계속 갱신 → 최종 M

# apples[k] = k번 사과의 (r, c) 좌표 를 저장하는 테이블
apples = [None] * (M + 1)            # 인덱스를 1부터 쓰려고 M+1칸 준비 (0번은 비움)
for r in range(N):
    for c in range(N):
        v = arr[r][c]                # 이 칸에 적힌 값 (0 또는 사과번호)
        if v > 0:                    # 사과가 있으면
            apples[v] = (r, c)       # v번 사과의 좌표를 그 자리(인덱스 v)에 기록

# 2) 시작 상태 설정
pos = (0, 0)                         # 플레이어 시작 위치: 좌상단
d = 0                                # 시작 방향: 동쪽(문제에서 0=동,1=남,2=서,3=북)
total = 0                            # 지금까지 누른 '오른쪽 방향키(=우회전)' 총 횟수

# 3) 1번 → 2번 → ... → M번 사과 순서대로 이동하며,
#    각 구간마다 '필요한 최소 우회전 횟수'를 누적한다.
for k in range(1, M + 1):
    B = apples[k]                    # 이번에 먹을 k번 사과의 좌표 (목표지점)

    # pivot_ok: 현재 칸에서 '즉시 1회 회전'을 허용할지 여부
    # - 첫 이동(시작칸→1번 사과): 시작칸이 사과가 아니므로 즉시 회전 불가(False)
    # - 그다음 이동(1번→2번, 2번→3번…): '사과를 먹으며 동시에 회전' 가능(True)
    pivot_ok = (k >= 2)              # 2번 사과부터는 True

    # turns(d, pos, B, pivot_ok):
    # - 현재 방향 d, 현재 위치 pos에서 목표 B로 갈 때
    #   오른쪽 회전만 사용한다는 조건에서
    #   필요한 최소 우회전 횟수 t와, B에 도착했을 때의 방향 end_dir을 반환
    t, d = turns(d, pos, B, pivot_ok=pivot_ok)

    total += t                       # 이번 구간에서 사용한 회전 횟수를 누적
    pos = B                          # 다음 구간의 출발점은 방금 먹은 사과 위치

# 4) 모든 사과를 순서대로 먹는 동안 눌러야 하는 총 회전 횟수 출력
print(f'#{test_case} {total}')
